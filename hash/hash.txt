
散列表（hashtable）是散列法法的底层基础，逻辑上由一系列用于存放词条的单元组成，这些单元称为桶。
[bucket1][bucket2]...[bucketn] 一般直接使用数组表示，若容量为R则合法秩[0, R)称为地址空间。

散列函数 hash() 用于计算词条与桶地址之间的映射关系。hash():key -> hash(key)，得到与关键码key
相对应的桶在散列表中的秩。
假设词条数为N，其关键码均为[0, R)内的整数，散列表长度为M，R >> M > N。hash()将关键码空间[0,R)
压缩为散列地址空间[0, M)。hash(E.key)为词条E在hashtable中的秩。由于R >> M，则冲突时不可避免的。
假设有10个词条对应的关键码{1000,1015,1030...1135}，散列表长M为20。
1. hash(x) = x % 20
1000 1060 1120关键码都会聚集到0号桶中，关键码集中到散列表内少数桶的现象称为关键码的聚集。
2. hash(x) = x % 19 即除留余数，没有出现关键码的聚集

装填因子 load factor = N/M，是对散列表性能影响最大的因素。随着装填因子的上升，词条会在散列表中
冲突的程度迅速加剧。

散列表使用场景：
1. 用来快速查找,需要从更多维度去理解，不要局限于一维数组，一维数组是最单纯的场景，用于屏蔽细节。
Entry<K, V> 表示一个词条，K表示词条的关键码。
bool put(K, V)
V get(K k)

散列表的基本思想是在一块连续的空间内开辟一个桶数组，借助hash()建立词条关键码到桶地址
hash(key)的映射，从而快速确定待操作词条的物理位置。所以无论如何都不能保证关键码对应
的桶不相同，所以冲突不可避免，
冲突处理方法有两类：
需要额外空间
1. 独立链法：将所有相互冲突的词条组成一个更小的词典结构，分别存放在其对应的桶单元中。
好处：可以便捷的实现映射结构，删除词条很方便
坏处：借助列表作为结构，将相互冲突的词条分组存放需要更多的空间和编码实现。
2. 公共溢出区法

不需要额外空间
1. 开放定地址法：不使用附加空间，当冲突时使用事先约定的查找方法。
策略有：线性试探法...
由于会形成查找链，所以删除词条不方便，一般为了兼顾效率会使用标记防止查找链中断，比如懒惰删除。

关键码 -hashcode()-> 散列码 -hash()->桶地址
